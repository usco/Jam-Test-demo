!function(e){function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var t={};return n.m=e,n.c=t,n.p="",n(0)}([function(module,exports,__webpack_require__){eval('/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\nvar PLY = __webpack_require__(2);\n\nself.onmessage = function (event) {\n  var data = event.data;\n  data = data.data;\n\n  var result = new PLY().load(data);\n\n  self.postMessage({ data: result });\n  self.close();\n};\n\n/* REACT HOT LOADER */ })(); if (false) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/makeExportsHot.js"), foundReactClasses = false; if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "ply-worker.js" + ": " + err.message); } }); } } })(); }\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader!./~/babel-loader?experimental&optional=runtime!./~/usco-ply-parser/ply-worker.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/usco-ply-parser/ply-worker.js?./~/react-hot-loader!./~/babel-loader?experimental&optional=runtime')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(process) {/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\n(function () {\n  // Hueristics.\n  var isNode = typeof process !== "undefined" && process.versions && !!process.versions.node;\n  var isBrowser = typeof window !== "undefined";\n  var isModule = typeof module !== "undefined" && !!module.exports;\n\n  // Export.\n  var detect = isModule ? exports : this.detect = {};\n  detect.isNode = isNode;\n  detect.isBrowser = isBrowser;\n  detect.isModule = isModule;\n}).call(undefined);\n\n/* REACT HOT LOADER */ })(); if (false) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/makeExportsHot.js"), foundReactClasses = false; if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "detect.js" + ": " + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/usco-ply-parser/~/composite-detect/src/detect.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/usco-ply-parser/~/composite-detect/src/detect.js?')},function(module,exports,__webpack_require__){eval('/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\nvar detectEnv = __webpack_require__(1);\n\nvar PLY = function PLY() {\n\n	var currentObject = {};\n	currentObject._attributes = {};\n	currentObject._attributes.position = [];\n	currentObject._attributes.normal = [];\n	currentObject._attributes.color = [];\n	currentObject._attributes.indices = [];\n	currentObject.faceCount = 0;\n\n	this.currentObject = currentObject;\n};\n\nPLY.prototype = {\n	constructor: PLY\n};\n\nPLY.prototype.load = function (data) {\n\n	if (data instanceof ArrayBuffer) {\n\n		var isASCII = this.isASCII(data);\n		if (isASCII) {\n			return this.parseASCII(this.bin2str(data));\n		} else {\n			return this.parseBinary(data);\n		}\n	} else {\n		return this.parseASCII(data);\n	}\n};\n\nPLY.prototype.bin2str = function (buf) {\n\n	var array_buffer = new Uint8Array(buf);\n	var str = "";\n	for (var i = 0; i < buf.byteLength; i++) {\n		str += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\n	}\n\n	return str;\n}, PLY.prototype.isASCII = function (data) {\n\n	var header = this.parseHeader(this.bin2str(data));\n\n	return header.format === "ascii";\n}, PLY.prototype.parseHeader = function (data) {\n\n	var patternHeader = /ply([\\s\\S]*)end_header\\n/;\n	var headerText = "";\n	var result;\n	if ((result = patternHeader.exec(data)) != null) {\n		headerText = result[1];\n	}\n\n	var header = new Object();\n	header.comments = [];\n	header.elements = [];\n	header.headerLength = result[0].length;\n\n	var lines = headerText.split("\\n");\n	var currentElement = undefined;\n	var lineType, lineValues;\n\n	function make_ply_element_property(propertValues) {\n\n		var property = Object();\n\n		property.type = propertValues[0];\n\n		if (property.type === "list") {\n\n			property.name = propertValues[3];\n			property.countType = propertValues[1];\n			property.itemType = propertValues[2];\n		} else {\n\n			property.name = propertValues[1];\n		}\n\n		return property;\n	}\n\n	for (var i = 0; i < lines.length; i++) {\n\n		var line = lines[i];\n		line = line.trim();\n		if (line === "") {\n			continue;\n		}\n		lineValues = line.split(/\\s+/);\n		lineType = lineValues.shift();\n		line = lineValues.join(" ");\n\n		switch (lineType) {\n\n			case "format":\n\n				header.format = lineValues[0];\n				header.version = lineValues[1];\n\n				break;\n\n			case "comment":\n\n				header.comments.push(line);\n\n				break;\n\n			case "element":\n\n				if (!(currentElement === undefined)) {\n\n					header.elements.push(currentElement);\n				}\n\n				currentElement = Object();\n				currentElement.name = lineValues[0];\n				currentElement.count = parseInt(lineValues[1]);\n				currentElement.properties = [];\n\n				break;\n\n			case "property":\n\n				currentElement.properties.push(make_ply_element_property(lineValues));\n\n				break;\n\n			default:\n				console.log("unhandled", lineType, lineValues);\n				//console.log(lineType);\n\n		}\n	}\n\n	if (!(currentElement === undefined)) {\n\n		header.elements.push(currentElement);\n	}\n\n	return header;\n}, PLY.prototype.parseASCIINumber = function (n, type) {\n\n	switch (type) {\n\n		case "char":case "uchar":case "short":case "ushort":case "int":case "uint":\n		case "int8":case "uint8":case "int16":case "uint16":case "int32":case "uint32":\n\n			return parseInt(n);\n\n		case "float":case "double":case "float32":case "float64":\n\n			return parseFloat(n);\n\n	}\n}, PLY.prototype.parseASCIIElement = function (properties, line) {\n\n	var values = line.split(/\\s+/);\n\n	var element = Object();\n\n	for (var i = 0; i < properties.length; i++) {\n\n		if (properties[i].type === "list") {\n\n			var list = [];\n			var n = this.parseASCIINumber(values.shift(), properties[i].countType);\n\n			for (var j = 0; j < n; j++) {\n\n				list.push(this.parseASCIINumber(values.shift(), properties[i].itemType));\n			}\n\n			element[properties[i].name] = list;\n		} else {\n\n			element[properties[i].name] = this.parseASCIINumber(values.shift(), properties[i].type);\n		}\n	}\n\n	return element;\n}, PLY.prototype.parseASCII = function (data) {\n\n	// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n	var geometry = {};\n	var result;\n\n	var header = this.parseHeader(data);\n\n	var patternBody = /end_header\\n([\\s\\S]*)$/;\n	var body = "";\n	if ((result = patternBody.exec(data)) != null) {\n		body = result[1];\n	}\n\n	var lines = body.split("\\n");\n	var currentElement = 0;\n	var currentElementCount = 0;\n\n	//FIXME:\n	//geometry.useColor = false;\n\n	for (var i = 0; i < lines.length; i++) {\n\n		var line = lines[i];\n		line = line.trim();\n		if (line === "") {\n			continue;\n		}\n\n		if (currentElementCount >= header.elements[currentElement].count) {\n\n			currentElement++;\n			currentElementCount = 0;\n		}\n\n		var element = this.parseASCIIElement(header.elements[currentElement].properties, line);\n\n		this.handleElement(geometry, header.elements[currentElement].name, element);\n\n		currentElementCount++;\n	}\n\n	//return this.postProcess( geometry );\n	return this.currentObject;\n};\n\nvar postProcess = function postProcess(geometry) {\n\n	if (geometry.useColor) {\n\n		for (var i = 0; i < geometry.faces.length; i++) {\n\n			geometry.faces[i].vertexColors = [geometry.colors[geometry.faces[i].a], geometry.colors[geometry.faces[i].b], geometry.colors[geometry.faces[i].c]];\n		}\n\n		geometry.elementsNeedUpdate = true;\n	}\n	return geometry;\n};\n\nPLY.prototype.handleElement = function (geometry, elementName, element) {\n\n	if (elementName === "vertex") {\n		this.currentObject._attributes.position.push(element.x, element.y, element.z);\n\n		if ("red" in element && "green" in element && "blue" in element) {\n			//console.log("colors");\n			this.currentObject._attributes.color.push(element.red, element.blue, element.green);\n		}\n	} else if (elementName === "face") {\n		//console.log("face");\n		this.currentObject.faceCount += 1;\n		this.currentObject._attributes.indices.push(element.vertex_indices[0], element.vertex_indices[1], element.vertex_indices[2]);\n	}\n\n	/*if ( elementName === "vertex" ) {\n 		geometry.vertices.push(\n 		new THREE.Vector3( element.x, element.y, element.z )\n 	);\n 	\n 	if ( \'red\' in element && \'green\' in element && \'blue\' in element ) {\n 		\n 		geometry.useColor = true;\n 		\n 		color = new THREE.Color();\n 		color.setRGB( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\n 		geometry.colors.push( color );\n 		\n 	}\n 	} else if ( elementName === "face" ) {\n 		geometry.faces.push(\n 		new THREE.Face3( element.vertex_indices[0], element.vertex_indices[1], element.vertex_indices[2] )\n 	);\n 	}*/\n};\n\nPLY.prototype.binaryRead = function (dataview, at, type, little_endian) {\n\n	switch (type) {\n\n		// corespondences for non-specific length types here match rply:\n		case "int8":case "char":\n			return [dataview.getInt8(at), 1];\n\n		case "uint8":case "uchar":\n			return [dataview.getUint8(at), 1];\n\n		case "int16":case "short":\n			return [dataview.getInt16(at, little_endian), 2];\n\n		case "uint16":case "ushort":\n			return [dataview.getUint16(at, little_endian), 2];\n\n		case "int32":case "int":\n			return [dataview.getInt32(at, little_endian), 4];\n\n		case "uint32":case "uint":\n			return [dataview.getUint32(at, little_endian), 4];\n\n		case "float32":case "float":\n			return [dataview.getFloat32(at, little_endian), 4];\n\n		case "float64":case "double":\n			return [dataview.getFloat64(at, little_endian), 8];\n\n	}\n}, PLY.prototype.binaryReadElement = function (dataview, at, properties, little_endian) {\n\n	var element = Object();\n	var result,\n	    read = 0;\n\n	for (var i = 0; i < properties.length; i++) {\n\n		if (properties[i].type === "list") {\n\n			var list = [];\n\n			result = this.binaryRead(dataview, at + read, properties[i].countType, little_endian);\n			var n = result[0];\n			read += result[1];\n\n			for (j = 0; j < n; j++) {\n\n				result = this.binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n				list.push(result[0]);\n				read += result[1];\n			}\n\n			element[properties[i].name] = list;\n		} else {\n\n			result = this.binaryRead(dataview, at + read, properties[i].type, little_endian);\n			element[properties[i].name] = result[0];\n			read += result[1];\n		}\n	}\n\n	return [element, read];\n};\n\nPLY.prototype.parseBinary = function (data) {\n\n	var geometry = {}; //new THREE.Geometry();\n\n	var header = this.parseHeader(this.bin2str(data));\n	var little_endian = header.format === "binary_little_endian";\n	var body = new DataView(data, header.headerLength);\n	var result,\n	    loc = 0;\n\n	for (var currentElement = 0; currentElement < header.elements.length; currentElement++) {\n\n		for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n\n			var result = this.binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n			loc += result[1];\n			var element = result[0];\n\n			this.handleElement(geometry, header.elements[currentElement].name, element);\n		}\n	}\n\n	//return this.postProcess( geometry );\n	return this.currentObject;\n};\n\nmodule.exports = PLY;\n\n/* REACT HOT LOADER */ })(); if (false) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/makeExportsHot.js"), foundReactClasses = false; if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "ply.js" + ": " + err.message); } }); } } })(); }\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/usco-ply-parser/ply.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/usco-ply-parser/ply.js?')},function(module,exports,__webpack_require__){eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/process/browser.js?")}]);