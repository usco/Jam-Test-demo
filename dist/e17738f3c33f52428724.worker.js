!function(e){function n(r){if(t[r])return t[r].exports;var i=t[r]={exports:{},id:r,loaded:!1};return e[r].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var t={};return n.m=e,n.c=t,n.p="/dist/",n(0)}([function(module,exports,__webpack_require__){eval('/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n//importScripts( "../ctm.js","lzma.js" );\n"use strict";\n\nvar CTM = __webpack_require__(3);\nvar lzma = __webpack_require__(1);\n\nself.onmessage = function (event) {\n\n	var files = [];\n\n	for (var i = 0; i < event.data.offsets.length; i++) {\n\n		var stream = new CTM.Stream(event.data.data);\n		stream.offset = event.data.offsets[i];\n\n		files[i] = new CTM.File(stream);\n	}\n\n	self.postMessage(files);\n	self.close();\n};\n\n/* REACT HOT LOADER */ })(); if (false) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/makeExportsHot.js"), foundReactClasses = false; if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "ctm-worker.js" + ": " + err.message); } }); } } })(); }\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader!./~/babel-loader?experimental&optional=runtime!./~/usco-ctm-parser/ctm-worker.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/usco-ctm-parser/ctm-worker.js?./~/react-hot-loader!./~/babel-loader?experimental&optional=runtime')},function(module,exports,__webpack_require__){eval('/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\nif (true) {\n  var detectEnv = __webpack_require__(2);\n}\n\nvar LZMA = LZMA || {};\n\nLZMA.OutWindow = function () {\n  this._windowSize = 0;\n};\n\nLZMA.OutWindow.prototype.create = function (windowSize) {\n  if (!this._buffer || this._windowSize !== windowSize) {\n    this._buffer = [];\n  }\n  this._windowSize = windowSize;\n  this._pos = 0;\n  this._streamPos = 0;\n};\n\nLZMA.OutWindow.prototype.flush = function () {\n  var size = this._pos - this._streamPos;\n  if (size !== 0) {\n    while (size--) {\n      this._stream.writeByte(this._buffer[this._streamPos++]);\n    }\n    if (this._pos >= this._windowSize) {\n      this._pos = 0;\n    }\n    this._streamPos = this._pos;\n  }\n};\n\nLZMA.OutWindow.prototype.releaseStream = function () {\n  this.flush();\n  this._stream = null;\n};\n\nLZMA.OutWindow.prototype.setStream = function (stream) {\n  this.releaseStream();\n  this._stream = stream;\n};\n\nLZMA.OutWindow.prototype.init = function (solid) {\n  if (!solid) {\n    this._streamPos = 0;\n    this._pos = 0;\n  }\n};\n\nLZMA.OutWindow.prototype.copyBlock = function (distance, len) {\n  var pos = this._pos - distance - 1;\n  if (pos < 0) {\n    pos += this._windowSize;\n  }\n  while (len--) {\n    if (pos >= this._windowSize) {\n      pos = 0;\n    }\n    this._buffer[this._pos++] = this._buffer[pos++];\n    if (this._pos >= this._windowSize) {\n      this.flush();\n    }\n  }\n};\n\nLZMA.OutWindow.prototype.putByte = function (b) {\n  this._buffer[this._pos++] = b;\n  if (this._pos >= this._windowSize) {\n    this.flush();\n  }\n};\n\nLZMA.OutWindow.prototype.getByte = function (distance) {\n  var pos = this._pos - distance - 1;\n  if (pos < 0) {\n    pos += this._windowSize;\n  }\n  return this._buffer[pos];\n};\n\nLZMA.RangeDecoder = function () {};\n\nLZMA.RangeDecoder.prototype.setStream = function (stream) {\n  this._stream = stream;\n};\n\nLZMA.RangeDecoder.prototype.releaseStream = function () {\n  this._stream = null;\n};\n\nLZMA.RangeDecoder.prototype.init = function () {\n  var i = 5;\n\n  this._code = 0;\n  this._range = -1;\n\n  while (i--) {\n    this._code = this._code << 8 | this._stream.readByte();\n  }\n};\n\nLZMA.RangeDecoder.prototype.decodeDirectBits = function (numTotalBits) {\n  var result = 0,\n      i = numTotalBits,\n      t;\n\n  while (i--) {\n    this._range >>>= 1;\n    t = this._code - this._range >>> 31;\n    this._code -= this._range & t - 1;\n    result = result << 1 | 1 - t;\n\n    if ((this._range & 4278190080) === 0) {\n      this._code = this._code << 8 | this._stream.readByte();\n      this._range <<= 8;\n    }\n  }\n\n  return result;\n};\n\nLZMA.RangeDecoder.prototype.decodeBit = function (probs, index) {\n  var prob = probs[index],\n      newBound = (this._range >>> 11) * prob;\n\n  if ((this._code ^ 2147483648) < (newBound ^ 2147483648)) {\n    this._range = newBound;\n    probs[index] += 2048 - prob >>> 5;\n    if ((this._range & 4278190080) === 0) {\n      this._code = this._code << 8 | this._stream.readByte();\n      this._range <<= 8;\n    }\n    return 0;\n  }\n\n  this._range -= newBound;\n  this._code -= newBound;\n  probs[index] -= prob >>> 5;\n  if ((this._range & 4278190080) === 0) {\n    this._code = this._code << 8 | this._stream.readByte();\n    this._range <<= 8;\n  }\n  return 1;\n};\n\nLZMA.initBitModels = function (probs, len) {\n  while (len--) {\n    probs[len] = 1024;\n  }\n};\n\nLZMA.BitTreeDecoder = function (numBitLevels) {\n  this._models = [];\n  this._numBitLevels = numBitLevels;\n};\n\nLZMA.BitTreeDecoder.prototype.init = function () {\n  LZMA.initBitModels(this._models, 1 << this._numBitLevels);\n};\n\nLZMA.BitTreeDecoder.prototype.decode = function (rangeDecoder) {\n  var m = 1,\n      i = this._numBitLevels;\n\n  while (i--) {\n    m = m << 1 | rangeDecoder.decodeBit(this._models, m);\n  }\n  return m - (1 << this._numBitLevels);\n};\n\nLZMA.BitTreeDecoder.prototype.reverseDecode = function (rangeDecoder) {\n  var m = 1,\n      symbol = 0,\n      i = 0,\n      bit;\n\n  for (; i < this._numBitLevels; ++i) {\n    bit = rangeDecoder.decodeBit(this._models, m);\n    m = m << 1 | bit;\n    symbol |= bit << i;\n  }\n  return symbol;\n};\n\nLZMA.reverseDecode2 = function (models, startIndex, rangeDecoder, numBitLevels) {\n  var m = 1,\n      symbol = 0,\n      i = 0,\n      bit;\n\n  for (; i < numBitLevels; ++i) {\n    bit = rangeDecoder.decodeBit(models, startIndex + m);\n    m = m << 1 | bit;\n    symbol |= bit << i;\n  }\n  return symbol;\n};\n\nLZMA.LenDecoder = function () {\n  this._choice = [];\n  this._lowCoder = [];\n  this._midCoder = [];\n  this._highCoder = new LZMA.BitTreeDecoder(8);\n  this._numPosStates = 0;\n};\n\nLZMA.LenDecoder.prototype.create = function (numPosStates) {\n  for (; this._numPosStates < numPosStates; ++this._numPosStates) {\n    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n  }\n};\n\nLZMA.LenDecoder.prototype.init = function () {\n  var i = this._numPosStates;\n  LZMA.initBitModels(this._choice, 2);\n  while (i--) {\n    this._lowCoder[i].init();\n    this._midCoder[i].init();\n  }\n  this._highCoder.init();\n};\n\nLZMA.LenDecoder.prototype.decode = function (rangeDecoder, posState) {\n  if (rangeDecoder.decodeBit(this._choice, 0) === 0) {\n    return this._lowCoder[posState].decode(rangeDecoder);\n  }\n  if (rangeDecoder.decodeBit(this._choice, 1) === 0) {\n    return 8 + this._midCoder[posState].decode(rangeDecoder);\n  }\n  return 16 + this._highCoder.decode(rangeDecoder);\n};\n\nLZMA.Decoder2 = function () {\n  this._decoders = [];\n};\n\nLZMA.Decoder2.prototype.init = function () {\n  LZMA.initBitModels(this._decoders, 768);\n};\n\nLZMA.Decoder2.prototype.decodeNormal = function (rangeDecoder) {\n  var symbol = 1;\n\n  do {\n    symbol = symbol << 1 | rangeDecoder.decodeBit(this._decoders, symbol);\n  } while (symbol < 256);\n\n  return symbol & 255;\n};\n\nLZMA.Decoder2.prototype.decodeWithMatchByte = function (rangeDecoder, matchByte) {\n  var symbol = 1,\n      matchBit,\n      bit;\n\n  do {\n    matchBit = matchByte >> 7 & 1;\n    matchByte <<= 1;\n    bit = rangeDecoder.decodeBit(this._decoders, (1 + matchBit << 8) + symbol);\n    symbol = symbol << 1 | bit;\n    if (matchBit !== bit) {\n      while (symbol < 256) {\n        symbol = symbol << 1 | rangeDecoder.decodeBit(this._decoders, symbol);\n      }\n      break;\n    }\n  } while (symbol < 256);\n\n  return symbol & 255;\n};\n\nLZMA.LiteralDecoder = function () {};\n\nLZMA.LiteralDecoder.prototype.create = function (numPosBits, numPrevBits) {\n  var i;\n\n  if (this._coders && this._numPrevBits === numPrevBits && this._numPosBits === numPosBits) {\n    return;\n  }\n  this._numPosBits = numPosBits;\n  this._posMask = (1 << numPosBits) - 1;\n  this._numPrevBits = numPrevBits;\n\n  this._coders = [];\n\n  i = 1 << this._numPrevBits + this._numPosBits;\n  while (i--) {\n    this._coders[i] = new LZMA.Decoder2();\n  }\n};\n\nLZMA.LiteralDecoder.prototype.init = function () {\n  var i = 1 << this._numPrevBits + this._numPosBits;\n  while (i--) {\n    this._coders[i].init();\n  }\n};\n\nLZMA.LiteralDecoder.prototype.getDecoder = function (pos, prevByte) {\n  return this._coders[((pos & this._posMask) << this._numPrevBits) + ((prevByte & 255) >>> 8 - this._numPrevBits)];\n};\n\nLZMA.Decoder = function () {\n  this._outWindow = new LZMA.OutWindow();\n  this._rangeDecoder = new LZMA.RangeDecoder();\n  this._isMatchDecoders = [];\n  this._isRepDecoders = [];\n  this._isRepG0Decoders = [];\n  this._isRepG1Decoders = [];\n  this._isRepG2Decoders = [];\n  this._isRep0LongDecoders = [];\n  this._posSlotDecoder = [];\n  this._posDecoders = [];\n  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);\n  this._lenDecoder = new LZMA.LenDecoder();\n  this._repLenDecoder = new LZMA.LenDecoder();\n  this._literalDecoder = new LZMA.LiteralDecoder();\n  this._dictionarySize = -1;\n  this._dictionarySizeCheck = -1;\n\n  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);\n};\n\nLZMA.Decoder.prototype.setDictionarySize = function (dictionarySize) {\n  if (dictionarySize < 0) {\n    return false;\n  }\n  if (this._dictionarySize !== dictionarySize) {\n    this._dictionarySize = dictionarySize;\n    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);\n    this._outWindow.create(Math.max(this._dictionarySizeCheck, 4096));\n  }\n  return true;\n};\n\nLZMA.Decoder.prototype.setLcLpPb = function (lc, lp, pb) {\n  var numPosStates = 1 << pb;\n\n  if (lc > 8 || lp > 4 || pb > 4) {\n    return false;\n  }\n\n  this._literalDecoder.create(lp, lc);\n\n  this._lenDecoder.create(numPosStates);\n  this._repLenDecoder.create(numPosStates);\n  this._posStateMask = numPosStates - 1;\n\n  return true;\n};\n\nLZMA.Decoder.prototype.init = function () {\n  var i = 4;\n\n  this._outWindow.init(false);\n\n  LZMA.initBitModels(this._isMatchDecoders, 192);\n  LZMA.initBitModels(this._isRep0LongDecoders, 192);\n  LZMA.initBitModels(this._isRepDecoders, 12);\n  LZMA.initBitModels(this._isRepG0Decoders, 12);\n  LZMA.initBitModels(this._isRepG1Decoders, 12);\n  LZMA.initBitModels(this._isRepG2Decoders, 12);\n  LZMA.initBitModels(this._posDecoders, 114);\n\n  this._literalDecoder.init();\n\n  while (i--) {\n    this._posSlotDecoder[i].init();\n  }\n\n  this._lenDecoder.init();\n  this._repLenDecoder.init();\n  this._posAlignDecoder.init();\n  this._rangeDecoder.init();\n};\n\nLZMA.Decoder.prototype.decode = function (inStream, outStream, outSize) {\n  var state = 0,\n      rep0 = 0,\n      rep1 = 0,\n      rep2 = 0,\n      rep3 = 0,\n      nowPos64 = 0,\n      prevByte = 0,\n      posState,\n      decoder2,\n      len,\n      distance,\n      posSlot,\n      numDirectBits;\n\n  this._rangeDecoder.setStream(inStream);\n  this._outWindow.setStream(outStream);\n\n  this.init();\n\n  while (outSize < 0 || nowPos64 < outSize) {\n    posState = nowPos64 & this._posStateMask;\n\n    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0) {\n      decoder2 = this._literalDecoder.getDecoder(nowPos64++, prevByte);\n\n      if (state >= 7) {\n        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0));\n      } else {\n        prevByte = decoder2.decodeNormal(this._rangeDecoder);\n      }\n      this._outWindow.putByte(prevByte);\n\n      state = state < 4 ? 0 : state - (state < 10 ? 3 : 6);\n    } else {\n\n      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1) {\n        len = 0;\n        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0) {\n          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0) {\n            state = state < 7 ? 9 : 11;\n            len = 1;\n          }\n        } else {\n          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0) {\n            distance = rep1;\n          } else {\n            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0) {\n              distance = rep2;\n            } else {\n              distance = rep3;\n              rep3 = rep2;\n            }\n            rep2 = rep1;\n          }\n          rep1 = rep0;\n          rep0 = distance;\n        }\n        if (len === 0) {\n          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);\n          state = state < 7 ? 8 : 11;\n        }\n      } else {\n        rep3 = rep2;\n        rep2 = rep1;\n        rep1 = rep0;\n\n        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);\n        state = state < 7 ? 7 : 10;\n\n        posSlot = this._posSlotDecoder[len <= 5 ? len - 2 : 3].decode(this._rangeDecoder);\n        if (posSlot >= 4) {\n\n          numDirectBits = (posSlot >> 1) - 1;\n          rep0 = (2 | posSlot & 1) << numDirectBits;\n\n          if (posSlot < 14) {\n            rep0 += LZMA.reverseDecode2(this._posDecoders, rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);\n          } else {\n            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;\n            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);\n            if (rep0 < 0) {\n              if (rep0 === -1) {\n                break;\n              }\n              return false;\n            }\n          }\n        } else {\n          rep0 = posSlot;\n        }\n      }\n\n      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck) {\n        return false;\n      }\n\n      this._outWindow.copyBlock(rep0, len);\n      nowPos64 += len;\n      prevByte = this._outWindow.getByte(0);\n    }\n  }\n\n  this._outWindow.flush();\n  this._outWindow.releaseStream();\n  this._rangeDecoder.releaseStream();\n\n  return true;\n};\n\nLZMA.Decoder.prototype.setDecoderProperties = function (properties) {\n  var value, lc, lp, pb, dictionarySize;\n\n  if (properties.size < 5) {\n    return false;\n  }\n\n  value = properties.readByte();\n  lc = value % 9;\n  value = ~ ~(value / 9);\n  lp = value % 5;\n  pb = ~ ~(value / 5);\n\n  if (!this.setLcLpPb(lc, lp, pb)) {\n    return false;\n  }\n\n  dictionarySize = properties.readByte();\n  dictionarySize |= properties.readByte() << 8;\n  dictionarySize |= properties.readByte() << 16;\n  dictionarySize += properties.readByte() * 16777216;\n\n  return this.setDictionarySize(dictionarySize);\n};\n\nLZMA.decompress = function (properties, inStream, outStream, outSize) {\n  var decoder = new LZMA.Decoder();\n\n  if (!decoder.setDecoderProperties(properties)) {\n    throw "Incorrect stream properties";\n  }\n\n  if (!decoder.decode(inStream, outStream, outSize)) {\n    throw "Error in data stream";\n  }\n\n  return true;\n};\n\nif (true) if (detectEnv.isModule) module.exports = LZMA;\n\n/* REACT HOT LOADER */ })(); if (false) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/makeExportsHot.js"), foundReactClasses = false; if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "lzma.js" + ": " + err.message); } }); } } })(); }\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/usco-ctm-parser/lzma.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/usco-ctm-parser/lzma.js?')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(process) {/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\n(function () {\n  // Hueristics.\n  var isNode = typeof process !== "undefined" && process.versions && !!process.versions.node;\n  var isBrowser = typeof window !== "undefined";\n  var isModule = typeof module !== "undefined" && !!module.exports;\n\n  // Export.\n  var detect = isModule ? exports : this.detect = {};\n  detect.isNode = isNode;\n  detect.isBrowser = isBrowser;\n  detect.isModule = isModule;\n}).call(undefined);\n\n/* REACT HOT LOADER */ })(); if (false) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/makeExportsHot.js"), foundReactClasses = false; if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "detect.js" + ": " + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/usco-ctm-parser/~/composite-detect/src/detect.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/usco-ctm-parser/~/composite-detect/src/detect.js?')},function(module,exports,__webpack_require__){eval('/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n/*\nCopyright (c) 2011 Juan Mellado\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/*\nReferences:\n- "OpenCTM: The Open Compressed Triangle Mesh file format" by Marcus Geelnard\n  http://openctm.sourceforge.net/\n*/\n\n"use strict";\n\nif (true) {\n  var detectEnv = __webpack_require__(2);\n  if (detectEnv.isModule) var LZMA = __webpack_require__(1);\n}\n\nvar CTM = CTM || {};\n\nCTM.CompressionMethod = {\n  RAW: 5718354,\n  MG1: 3229517,\n  MG2: 3295053\n};\n\nCTM.Flags = {\n  NORMALS: 1\n};\n\nCTM.File = function (stream) {\n  this.load(stream);\n};\n\nCTM.File.prototype.load = function (stream) {\n  this.header = new CTM.FileHeader(stream);\n  this.body = new CTM.FileBody(this.header);\n\n  this.getReader().read(stream, this.body);\n  /*  var reader = this.getReader();\n    reader.read(stream, this.body);*/\n};\n\nCTM.File.prototype.getReader = function () {\n  var reader;\n\n  switch (this.header.compressionMethod) {\n    case CTM.CompressionMethod.RAW:\n      reader = new CTM.ReaderRAW();\n      break;\n    case CTM.CompressionMethod.MG1:\n      reader = new CTM.ReaderMG1();\n      break;\n    case CTM.CompressionMethod.MG2:\n      reader = new CTM.ReaderMG2();\n      break;\n  }\n\n  return reader;\n};\n\nCTM.FileHeader = function (stream) {\n  stream.readInt32(); //magic "OCTM"\n  this.fileFormat = stream.readInt32();\n  this.compressionMethod = stream.readInt32();\n  this.vertexCount = stream.readInt32();\n  this.triangleCount = stream.readInt32();\n  this.uvMapCount = stream.readInt32();\n  this.attrMapCount = stream.readInt32();\n  this.flags = stream.readInt32();\n  this.comment = stream.readString();\n};\n\nCTM.FileHeader.prototype.hasNormals = function () {\n  return this.flags & CTM.Flags.NORMALS;\n};\n\nCTM.FileBody = function (header) {\n  var i = header.triangleCount * 3,\n      v = header.vertexCount * 3,\n      n = header.hasNormals() ? header.vertexCount * 3 : 0,\n      u = header.vertexCount * 2,\n      a = header.vertexCount * 4,\n      j = 0;\n\n  var data = new ArrayBuffer((i + v + n + u * header.uvMapCount + a * header.attrMapCount) * 4);\n\n  this.indices = new Uint32Array(data, 0, i);\n\n  this.vertices = new Float32Array(data, i * 4, v);\n\n  if (header.hasNormals()) {\n    this.normals = new Float32Array(data, (i + v) * 4, n);\n  }\n\n  if (header.uvMapCount) {\n    this.uvMaps = [];\n    for (j = 0; j < header.uvMapCount; ++j) {\n      this.uvMaps[j] = { uv: new Float32Array(data, (i + v + n + j * u) * 4, u) };\n    }\n  }\n\n  if (header.attrMapCount) {\n    this.attrMaps = [];\n    for (j = 0; j < header.attrMapCount; ++j) {\n      this.attrMaps[j] = { attr: new Float32Array(data, (i + v + n + u * header.uvMapCount + j * a) * 4, a) };\n    }\n  }\n};\n\nCTM.FileMG2Header = function (stream) {\n  stream.readInt32(); //magic "MG2H"\n  this.vertexPrecision = stream.readFloat32();\n  this.normalPrecision = stream.readFloat32();\n  this.lowerBoundx = stream.readFloat32();\n  this.lowerBoundy = stream.readFloat32();\n  this.lowerBoundz = stream.readFloat32();\n  this.higherBoundx = stream.readFloat32();\n  this.higherBoundy = stream.readFloat32();\n  this.higherBoundz = stream.readFloat32();\n  this.divx = stream.readInt32();\n  this.divy = stream.readInt32();\n  this.divz = stream.readInt32();\n\n  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;\n  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;\n  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;\n};\n\nCTM.ReaderRAW = function () {};\n\nCTM.ReaderRAW.prototype.read = function (stream, body) {\n  this.readIndices(stream, body.indices);\n  this.readVertices(stream, body.vertices);\n\n  if (body.normals) {\n    this.readNormals(stream, body.normals);\n  }\n  if (body.uvMaps) {\n    this.readUVMaps(stream, body.uvMaps);\n  }\n  if (body.attrMaps) {\n    this.readAttrMaps(stream, body.attrMaps);\n  }\n};\n\nCTM.ReaderRAW.prototype.readIndices = function (stream, indices) {\n  stream.readInt32(); //magic "INDX"\n  stream.readArrayInt32(indices);\n};\n\nCTM.ReaderRAW.prototype.readVertices = function (stream, vertices) {\n  stream.readInt32(); //magic "VERT"\n  stream.readArrayFloat32(vertices);\n};\n\nCTM.ReaderRAW.prototype.readNormals = function (stream, normals) {\n  stream.readInt32(); //magic "NORM"\n  stream.readArrayFloat32(normals);\n};\n\nCTM.ReaderRAW.prototype.readUVMaps = function (stream, uvMaps) {\n  var i = 0;\n  for (; i < uvMaps.length; ++i) {\n    stream.readInt32(); //magic "TEXC"\n\n    uvMaps[i].name = stream.readString();\n    uvMaps[i].filename = stream.readString();\n    stream.readArrayFloat32(uvMaps[i].uv);\n  }\n};\n\nCTM.ReaderRAW.prototype.readAttrMaps = function (stream, attrMaps) {\n  var i = 0;\n  for (; i < attrMaps.length; ++i) {\n    stream.readInt32(); //magic "ATTR"\n\n    attrMaps[i].name = stream.readString();\n    stream.readArrayFloat32(attrMaps[i].attr);\n  }\n};\n\nCTM.ReaderMG1 = function () {};\n\nCTM.ReaderMG1.prototype.read = function (stream, body) {\n  this.readIndices(stream, body.indices);\n  this.readVertices(stream, body.vertices);\n\n  if (body.normals) {\n    this.readNormals(stream, body.normals);\n  }\n  if (body.uvMaps) {\n    this.readUVMaps(stream, body.uvMaps);\n  }\n  if (body.attrMaps) {\n    this.readAttrMaps(stream, body.attrMaps);\n  }\n};\n\nCTM.ReaderMG1.prototype.readIndices = function (stream, indices) {\n  stream.readInt32(); //magic "INDX"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(indices, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n  CTM.restoreIndices(indices, indices.length);\n};\n\nCTM.ReaderMG1.prototype.readVertices = function (stream, vertices) {\n  stream.readInt32(); //magic "VERT"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(vertices, 1);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n};\n\nCTM.ReaderMG1.prototype.readNormals = function (stream, normals) {\n  stream.readInt32(); //magic "NORM"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(normals, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n};\n\nCTM.ReaderMG1.prototype.readUVMaps = function (stream, uvMaps) {\n  var i = 0;\n  for (; i < uvMaps.length; ++i) {\n    stream.readInt32(); //magic "TEXC"\n\n    uvMaps[i].name = stream.readString();\n    uvMaps[i].filename = stream.readString();\n\n    stream.readInt32(); //packed size\n\n    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n  }\n};\n\nCTM.ReaderMG1.prototype.readAttrMaps = function (stream, attrMaps) {\n  var i = 0;\n  for (; i < attrMaps.length; ++i) {\n    stream.readInt32(); //magic "ATTR"\n\n    attrMaps[i].name = stream.readString();\n\n    stream.readInt32(); //packed size\n\n    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n  }\n};\n\nCTM.ReaderMG2 = function () {};\n\nCTM.ReaderMG2.prototype.read = function (stream, body) {\n  this.MG2Header = new CTM.FileMG2Header(stream);\n\n  this.readVertices(stream, body.vertices);\n  this.readIndices(stream, body.indices);\n\n  if (body.normals) {\n    this.readNormals(stream, body);\n  }\n  if (body.uvMaps) {\n    this.readUVMaps(stream, body.uvMaps);\n  }\n  if (body.attrMaps) {\n    this.readAttrMaps(stream, body.attrMaps);\n  }\n};\n\nCTM.ReaderMG2.prototype.readVertices = function (stream, vertices) {\n  stream.readInt32(); //magic "VERT"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(vertices, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n  var gridIndices = this.readGridIndices(stream, vertices);\n\n  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);\n};\n\nCTM.ReaderMG2.prototype.readGridIndices = function (stream, vertices) {\n  stream.readInt32(); //magic "GIDX"\n  stream.readInt32(); //packed size\n\n  var gridIndices = new Uint32Array(vertices.length / 3);\n\n  var interleaved = new CTM.InterleavedStream(gridIndices, 1);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n  CTM.restoreGridIndices(gridIndices, gridIndices.length);\n\n  return gridIndices;\n};\n\nCTM.ReaderMG2.prototype.readIndices = function (stream, indices) {\n  stream.readInt32(); //magic "INDX"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(indices, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n  CTM.restoreIndices(indices, indices.length);\n};\n\nCTM.ReaderMG2.prototype.readNormals = function (stream, body) {\n  stream.readInt32(); //magic "NORM"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(body.normals, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);\n\n  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);\n};\n\nCTM.ReaderMG2.prototype.readUVMaps = function (stream, uvMaps) {\n  var i = 0;\n  for (; i < uvMaps.length; ++i) {\n    stream.readInt32(); //magic "TEXC"\n\n    uvMaps[i].name = stream.readString();\n    uvMaps[i].filename = stream.readString();\n\n    var precision = stream.readFloat32();\n\n    stream.readInt32(); //packed size\n\n    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n    CTM.restoreMap(uvMaps[i].uv, 2, precision);\n  }\n};\n\nCTM.ReaderMG2.prototype.readAttrMaps = function (stream, attrMaps) {\n  var i = 0;\n  for (; i < attrMaps.length; ++i) {\n    stream.readInt32(); //magic "ATTR"\n\n    attrMaps[i].name = stream.readString();\n\n    var precision = stream.readFloat32();\n\n    stream.readInt32(); //packed size\n\n    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n    CTM.restoreMap(attrMaps[i].attr, 4, precision);\n  }\n};\n\nCTM.restoreIndices = function (indices, len) {\n  var i = 3;\n  if (len > 0) {\n    indices[2] += indices[0];\n    indices[1] += indices[0];\n  }\n  for (; i < len; i += 3) {\n    indices[i] += indices[i - 3];\n\n    if (indices[i] === indices[i - 3]) {\n      indices[i + 1] += indices[i - 2];\n    } else {\n      indices[i + 1] += indices[i];\n    }\n\n    indices[i + 2] += indices[i];\n  }\n};\n\nCTM.restoreGridIndices = function (gridIndices, len) {\n  var i = 1;\n  for (; i < len; ++i) {\n    gridIndices[i] += gridIndices[i - 1];\n  }\n};\n\nCTM.restoreVertices = function (vertices, grid, gridIndices, precision) {\n  var gridIdx,\n      delta,\n      x,\n      y,\n      z,\n      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),\n      ydiv = grid.divx,\n      zdiv = ydiv * grid.divy,\n      prevGridIdx = 2147483647,\n      prevDelta = 0,\n      i = 0,\n      j = 0,\n      len = gridIndices.length;\n\n  for (; i < len; j += 3) {\n    x = gridIdx = gridIndices[i++];\n\n    z = ~ ~(x / zdiv);\n    x -= ~ ~(z * zdiv);\n    y = ~ ~(x / ydiv);\n    x -= ~ ~(y * ydiv);\n\n    delta = intVertices[j];\n    if (gridIdx === prevGridIdx) {\n      delta += prevDelta;\n    }\n\n    vertices[j] = grid.lowerBoundx + x * grid.sizex + precision * delta;\n    vertices[j + 1] = grid.lowerBoundy + y * grid.sizey + precision * intVertices[j + 1];\n    vertices[j + 2] = grid.lowerBoundz + z * grid.sizez + precision * intVertices[j + 2];\n\n    prevGridIdx = gridIdx;\n    prevDelta = delta;\n  }\n};\n\nCTM.restoreNormals = function (normals, smooth, precision) {\n  var ro,\n      phi,\n      theta,\n      sinPhi,\n      nx,\n      ny,\n      nz,\n      by,\n      bz,\n      len,\n      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),\n      i = 0,\n      k = normals.length,\n      PI_DIV_2 = 3.141592653589793 * 0.5;\n\n  for (; i < k; i += 3) {\n    ro = intNormals[i] * precision;\n    phi = intNormals[i + 1];\n\n    if (phi === 0) {\n      normals[i] = smooth[i] * ro;\n      normals[i + 1] = smooth[i + 1] * ro;\n      normals[i + 2] = smooth[i + 2] * ro;\n    } else {\n\n      if (phi <= 4) {\n        theta = (intNormals[i + 2] - 2) * PI_DIV_2;\n      } else {\n        theta = (intNormals[i + 2] * 4 / phi - 2) * PI_DIV_2;\n      }\n\n      phi *= precision * PI_DIV_2;\n      sinPhi = ro * Math.sin(phi);\n\n      nx = sinPhi * Math.cos(theta);\n      ny = sinPhi * Math.sin(theta);\n      nz = ro * Math.cos(phi);\n\n      bz = smooth[i + 1];\n      by = smooth[i] - smooth[i + 2];\n\n      len = Math.sqrt(2 * bz * bz + by * by);\n      if (len > 1e-20) {\n        by /= len;\n        bz /= len;\n      }\n\n      normals[i] = smooth[i] * nz + (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;\n      normals[i + 1] = smooth[i + 1] * nz - (smooth[i + 2] + smooth[i]) * bz * ny + by * nx;\n      normals[i + 2] = smooth[i + 2] * nz + (smooth[i] * by + smooth[i + 1] * bz) * ny + bz * nx;\n    }\n  }\n};\n\nCTM.restoreMap = function (map, count, precision) {\n  var delta,\n      value,\n      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),\n      i = 0,\n      j,\n      len = map.length;\n\n  for (; i < count; ++i) {\n    delta = 0;\n\n    for (j = i; j < len; j += count) {\n      value = intMap[j];\n\n      delta += value & 1 ? -(value + 1 >> 1) : value >> 1;\n\n      map[j] = delta * precision;\n    }\n  }\n};\n\nCTM.calcSmoothNormals = function (indices, vertices) {\n  var smooth = new Float32Array(vertices.length),\n      indx,\n      indy,\n      indz,\n      nx,\n      ny,\n      nz,\n      v1x,\n      v1y,\n      v1z,\n      v2x,\n      v2y,\n      v2z,\n      len,\n      i,\n      k;\n\n  for (i = 0, k = indices.length; i < k;) {\n    indx = indices[i++] * 3;\n    indy = indices[i++] * 3;\n    indz = indices[i++] * 3;\n\n    v1x = vertices[indy] - vertices[indx];\n    v2x = vertices[indz] - vertices[indx];\n    v1y = vertices[indy + 1] - vertices[indx + 1];\n    v2y = vertices[indz + 1] - vertices[indx + 1];\n    v1z = vertices[indy + 2] - vertices[indx + 2];\n    v2z = vertices[indz + 2] - vertices[indx + 2];\n\n    nx = v1y * v2z - v1z * v2y;\n    ny = v1z * v2x - v1x * v2z;\n    nz = v1x * v2y - v1y * v2x;\n\n    len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n    if (len > 1e-10) {\n      nx /= len;\n      ny /= len;\n      nz /= len;\n    }\n\n    smooth[indx] += nx;\n    smooth[indx + 1] += ny;\n    smooth[indx + 2] += nz;\n    smooth[indy] += nx;\n    smooth[indy + 1] += ny;\n    smooth[indy + 2] += nz;\n    smooth[indz] += nx;\n    smooth[indz + 1] += ny;\n    smooth[indz + 2] += nz;\n  }\n\n  for (i = 0, k = smooth.length; i < k; i += 3) {\n    len = Math.sqrt(smooth[i] * smooth[i] + smooth[i + 1] * smooth[i + 1] + smooth[i + 2] * smooth[i + 2]);\n\n    if (len > 1e-10) {\n      smooth[i] /= len;\n      smooth[i + 1] /= len;\n      smooth[i + 2] /= len;\n    }\n  }\n\n  return smooth;\n};\n\nCTM.isLittleEndian = (function () {\n  var buffer = new ArrayBuffer(2),\n      bytes = new Uint8Array(buffer),\n      ints = new Uint16Array(buffer);\n\n  bytes[0] = 1;\n\n  return ints[0] === 1;\n})();\n\nCTM.InterleavedStream = function (data, count) {\n  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  this.offset = CTM.isLittleEndian ? 3 : 0;\n  this.count = count * 4;\n  this.len = this.data.length;\n};\n\nCTM.InterleavedStream.prototype.writeByte = function (value) {\n  this.data[this.offset] = value;\n\n  this.offset += this.count;\n  if (this.offset >= this.len) {\n\n    this.offset -= this.len - 4;\n    if (this.offset >= this.count) {\n\n      this.offset -= this.count + (CTM.isLittleEndian ? 1 : -1);\n    }\n  }\n};\n\nCTM.Stream = function (data) {\n  this.data = data;\n  this.offset = 0;\n};\n\nCTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);\n\nCTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);\n\nCTM.Stream.prototype.readByte = function () {\n  return this.data[this.offset++] & 255;\n};\n\nCTM.Stream.prototype.readInt32 = function () {\n  var i = this.readByte();\n  i |= this.readByte() << 8;\n  i |= this.readByte() << 16;\n  return i | this.readByte() << 24;\n};\n\nCTM.Stream.prototype.readFloat32 = function () {\n  var m = this.readByte();\n  m += this.readByte() << 8;\n\n  var b1 = this.readByte();\n  var b2 = this.readByte();\n\n  m += (b1 & 127) << 16;\n  var e = (b2 & 127) << 1 | (b1 & 128) >>> 7;\n  var s = b2 & 128 ? -1 : 1;\n\n  if (e === 255) {\n    return m !== 0 ? NaN : s * Infinity;\n  }\n  if (e > 0) {\n    return s * (1 + m * this.TWO_POW_MINUS23) * Math.pow(2, e - 127);\n  }\n  if (m !== 0) {\n    return s * m * this.TWO_POW_MINUS126;\n  }\n  return s * 0;\n};\n\nCTM.Stream.prototype.readString = function () {\n  var len = this.readInt32();\n\n  this.offset += len;\n\n  return String.fromCharCode.apply(null, this.data.subarray(this.offset - len, this.offset));\n};\n\nCTM.Stream.prototype.readArrayInt32 = function (array) {\n  var i = 0,\n      len = array.length;\n\n  while (i < len) {\n    array[i++] = this.readInt32();\n  }\n\n  return array;\n};\n\nCTM.Stream.prototype.readArrayFloat32 = function (array) {\n  var i = 0,\n      len = array.length;\n\n  while (i < len) {\n    array[i++] = this.readFloat32();\n  }\n\n  return array;\n};\n\n// browserify support\nif (true) {\n\n  module.exports = CTM;\n}\n\nif (true) if (detectEnv.isModule) module.exports = CTM;\n\n/* REACT HOT LOADER */ })(); if (false) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/makeExportsHot.js"), foundReactClasses = false; if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "ctm.js" + ": " + err.message); } }); } } })(); }\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/usco-ctm-parser/ctm.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/usco-ctm-parser/ctm.js?');

},function(module,exports,__webpack_require__){eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/process/browser.js?")}]);