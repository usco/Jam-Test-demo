!function(e){function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var t={};return n.m=e,n.c=t,n.p="./dist/",n(0)}([function(module,exports,__webpack_require__){eval('/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n//importScripts(\'./stl-utils.js\');\n"use strict";\n\nvar stlUtils = __webpack_require__(1);\n\nself.ensureBinary = function (buf) {\n\n	if (typeof buf === "string") {\n		var array_buffer = new Uint8Array(buf.length);\n		for (var i = 0; i < buf.length; i++) {\n			array_buffer[i] = buf.charCodeAt(i) & 255; // implicitly assumes little-endian\n		}\n		return array_buffer.buffer || array_buffer;\n	} else {\n		return buf;\n	}\n};\n\nself.parseASCII = function (data) {\n\n	var normal, patternFace, patternNormal, patternVertex, result, text;\n	patternFace = /facet([\\s\\S]*?)endfacet/g;\n\n	var posArray = [];\n	var normArray = [];\n	var indicesArray = [];\n	var faces = 0;\n\n	while ((result = patternFace.exec(data)) !== null) {\n		var length = 0;\n\n		text = result[0];\n		patternNormal = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n		while ((result = patternNormal.exec(text)) !== null) {\n			normArray.push(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));\n			normArray.push(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));\n			normArray.push(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));\n		}\n\n		patternVertex = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n		while ((result = patternVertex.exec(text)) !== null) {\n\n			posArray.push(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));\n			length += 1;\n		}\n		faces += 1;\n	}\n\n	var vertices = new Float32Array(faces * 3 * 3);\n	var normals = new Float32Array(faces * 3 * 3);\n\n	vertices.set(posArray);\n	normals.set(normArray);\n\n	return { vertices: vertices, normals: normals };\n};\n\nself.parseBinary = function (data) {\n	var reader = new DataView(data);\n	var faces = reader.getUint32(80, true);\n	var dataOffset = 84;\n	var faceLength = 12 * 4 + 2;\n\n	var offset = 0;\n\n	var vertices = new Float32Array(faces * 3 * 3);\n	var normals = new Float32Array(faces * 3 * 3);\n\n	for (var face = 0; face < faces; face++) {\n\n		var start = dataOffset + face * faceLength;\n\n		for (var i = 1; i <= 3; i++) {\n\n			var vertexstart = start + i * 12;\n\n			vertices[offset] = reader.getFloat32(vertexstart, true);\n			vertices[offset + 1] = reader.getFloat32(vertexstart + 4, true);\n			vertices[offset + 2] = reader.getFloat32(vertexstart + 8, true);\n\n			normals[offset] = reader.getFloat32(start, true);\n			normals[offset + 1] = reader.getFloat32(start + 4, true);\n			normals[offset + 2] = reader.getFloat32(start + 8, true);\n			offset += 3;\n		}\n	}\n	return { vertices: vertices, normals: normals };\n};\n\nself.onmessage = function (event) {\n	var data = event.data;\n	data = data.data;\n	data = stlUtils.ensureBinary(data);\n	var isBinary = stlUtils.isBinary(data);\n	if (!isBinary) {\n		data = stlUtils.ensureString(data);\n	}\n\n	var result = null;\n	if (isBinary) {\n		result = self.parseBinary(data);\n	} else {\n		result = self.parseASCII(data);\n	};\n\n	var vertices = result.vertices.buffer;\n	var normals = result.normals.buffer;\n	self.postMessage({ vertices: vertices, normals: normals }, [vertices, normals]);\n	self.close();\n};\n\n/* REACT HOT LOADER */ })(); if (false) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/makeExportsHot.js"), foundReactClasses = false; if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "stl-worker.js" + ": " + err.message); } }); } } })(); }\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader!./~/babel-loader?experimental&optional=runtime!./~/usco-stl-parser/stl-worker.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/usco-stl-parser/stl-worker.js?./~/react-hot-loader!./~/babel-loader?experimental&optional=runtime')},function(module,exports,__webpack_require__){eval('/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\nvar ensureBinary = function ensureBinary(buf) {\n\n	if (typeof buf === "string") {\n		var array_buffer = new Uint8Array(buf.length);\n		for (var i = 0; i < buf.length; i++) {\n			array_buffer[i] = buf.charCodeAt(i) & 255; // implicitly assumes little-endian\n		}\n		return array_buffer.buffer || array_buffer;\n	} else {\n		return buf;\n	}\n};\n\nvar ensureString = function ensureString(buf) {\n\n	if (typeof buf !== "string") {\n		var array_buffer = new Uint8Array(buf);\n		var str = "";\n		for (var i = 0; i < buf.byteLength; i++) {\n			str += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\n		}\n		return str;\n	} else {\n		return buf;\n	}\n};\n\nvar isBinary = function isBinary(data) {\n	var expect, face_size, n_faces, reader;\n	reader = new DataView(data);\n	face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n\n	n_faces = reader.getUint32(80, true);\n	expect = 80 + 32 / 8 + n_faces * face_size;\n	return expect === reader.byteLength;\n};\n\nmodule.exports.ensureBinary = ensureBinary;\nmodule.exports.ensureString = ensureString;\nmodule.exports.isBinary = isBinary;\n\n/* REACT HOT LOADER */ })(); if (false) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/kraftwerk-mb/dev/projects/usco/exp/node_modules/react-hot-loader/makeExportsHot.js"), foundReactClasses = false; if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "stl-utils.js" + ": " + err.message); } }); } } })(); }\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/usco-stl-parser/stl-utils.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/usco-stl-parser/stl-utils.js?')}]);